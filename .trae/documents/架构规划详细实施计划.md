# TQLSlib 架构规划详细实施计划

## 一、功能需求分析

### 1.1 核心设计理念
1. **单一职责原则 (SRP)**：每个类只负责一个功能领域
2. **开闭原则 (OCP)**：对扩展开放，对修改关闭
3. **依赖倒置原则 (DIP)**：依赖抽象而非具体实现
4. **接口隔离原则 (ISP)**：提供最小接口
5. **低耦合高内聚**：模块间依赖最小化，模块内功能最大化
6. **可扩展性**：支持其他模组通过 JSON 定义新内容
7. **可维护性**：代码结构清晰，易于理解和修改

### 1.2 现有功能清单
| 功能模块 | 状态 | 说明 |
|---------|------|------|
| 空间站系统 | ✅ 已实现 | 创建/删除/重命名、数据持久化、UI 界面 |
| 工具类库 | ✅ 已实现 | TQDrawf（绘图）、TQUtls（通用工具） |
| 内容注册 | ✅ 已实现 | ClassMap 注册，带 tqls- 前缀 |
| 方块系统 | ✅ 已实现 | PowerTower、各种物流方块 |
| 状态效果 | ✅ 已实现 | ExtentionStatus |

### 1.3 新增功能需求
| 功能模块 | 优先级 | 说明 |
|---------|--------|------|
| API 层 | P0 | 提供公共 API 供其他模组调用 |
| 配置系统 | P1 | 支持 JSON 配置解析，支持其他模组通过 JSON 定义内容 |
| 事件系统 | P1 | 提供事件总线，支持模块间松耦合通信 |
| 内容注册表 | P1 | 统一管理内容注册 |
| 文档系统 | P2 | API 文档、使用示例 |

---

## 二、模块划分方案

### 2.1 最终包结构

```
tqlslib/
├── api/                    # 公共 API 层（供其他模组调用）
│   ├── SpaceStationAPI.java       # 空间站 API 接口
│   ├── ContentRegistry.java       # 内容注册 API 接口
│   └── EventBus.java              # 事件总线 API 接口
│
├── core/                   # 核心业务逻辑层
│   ├── SpaceStationCore.java      # 空间站核心逻辑实现
│   ├── SpaceStationManager.java   # 空间站管理器（门面模式）
│   ├── SpaceStationIO.java        # 空间站 IO 操作
│   └── ContentRegistryCore.java   # 内容注册核心实现
│
├── type/                   # 数据类型定义层
│   ├── SpaceStation.java           # 空间站实体
│   ├── SpaceStationInfo.java       # 空间站信息
│   ├── status/
│   │   └── ExtentionStatus.java    # 状态效果
│   └── maps/
│       └── planet/
│           └── SpaceStationGenerator.java  # 星球生成器
│
├── ui/                     # UI 层
│   ├── SpaceStationDialogs.java    # 空间站对话框
│   └── dialogs/                    # 可扩展的对话框基类
│
├── config/                 # 配置系统（新增）
│   ├── ConfigLoader.java            # 配置加载器
│   ├── ContentParser.java           # 内容解析器抽象基类
│   └── parser/                      # 具体解析器
│       ├── BlockParser.java
│       ├── StatusParser.java
│       └── PlanetParser.java
│
├── util/                   # 工具类层
│   ├── TQDrawf.java                 # 绘图工具
│   ├── TQUtils.java                 # 通用工具（修正拼写）
│   └── TimeUtils.java               # 时间工具（拆分）
│
├── content/                # 内容定义层
│   ├── MxStats.java                 # 统计数据
│   └── registry/                    # 内容注册表
│       └── ClassRegistry.java       # 类注册表
│
├── event/                  # 事件系统（新增）
│   ├── TQLEvent.java                # 事件基类
│   ├── EventBusImpl.java            # 事件总线实现
│   └── events/                      # 具体事件
│       ├── SpaceStationCreateEvent.java
│       ├── SpaceStationRemoveEvent.java
│       └── SpaceStationRenameEvent.java
│
├── worlds/                 # 游戏世界层
│   └── blocks/                      # 方块定义
│       ├── power/
│       │   └── PowerTower.java
│       └── distribution/
│           ├── CoreUnloader_Import.java
│           ├── CoreUnloader_Output.java
│           ├── LiquidTransferStation.java
│           ├── Liquid_Import.java
│           └── Liquid_Output.java
│
├── DTVars.java             # 全局变量（将重构）
└── TQLSlib.java            # 主入口类
```

### 2.2 模块职责说明

| 模块 | 职责 | 依赖关系 |
|------|------|---------|
| **api** | 定义公共接口，供其他模组调用 | 不依赖其他业务模块 |
| **core** | 实现核心业务逻辑 | 依赖 api、type |
| **type** | 定义数据类型和实体 | 不依赖其他业务模块 |
| **ui** | 用户界面 | 依赖 api、core |
| **config** | 配置加载和解析 | 依赖 api、type |
| **util** | 通用工具类 | 不依赖其他业务模块 |
| **content** | 内容定义和注册表 | 依赖 api、core |
| **event** | 事件系统 | 依赖 api |
| **worlds** | 游戏世界元素（方块等） | 依赖 type、util |

---

## 三、类结构设计

### 3.1 API 层设计

#### SpaceStationAPI.java - 空间站 API 接口
```java
package tqlslib.api;

import arc.struct.Seq;
import mindustry.type.Planet;
import tqlslib.type.SpaceStation;
import tqlslib.type.SpaceStationInfo;

public interface SpaceStationAPI {
    SpaceStation createStation(Planet parent, String name);
    boolean removeStation(String stationId);
    boolean renameStation(String stationId, String newName);
    Seq<SpaceStationInfo> getStationsByPlanet(Planet planet);
    SpaceStation getStationById(String stationId);
    SpaceStationInfo getStationInfoById(String stationId);
    int getNextStationNumber(Planet planet);
    boolean stationExists(String stationId);
    Seq<SpaceStationInfo> getAllStations();
    int getStationCount();
    int getStationCountByPlanet(Planet planet);
}
```

#### ContentRegistry.java - 内容注册 API 接口
```java
package tqlslib.api;

public interface ContentRegistry {
    void registerClass(String name, Class<?> clazz);
    Class<?> getClass(String name);
    boolean hasClass(String name);
    String getPrefix();
}
```

#### EventBus.java - 事件总线 API 接口
```java
package tqlslib.api;

import tqlslib.event.TQLEvent;
import java.util.function.Consumer;

public interface EventBus {
    <T extends TQLEvent> void subscribe(Class<T> eventType, Consumer<T> handler);
    <T extends TQLEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler);
    <T extends TQLEvent> void post(T event);
}
```

### 3.2 核心层设计

#### SpaceStationCore.java - 空间站核心逻辑实现
```java
package tqlslib.core;

import tqlslib.api.SpaceStationAPI;

public class SpaceStationCore implements SpaceStationAPI {
    @Override
    public SpaceStation createStation(Planet parent, String name) {
        // 实现逻辑
    }
    
    // 其他方法实现...
}
```

#### ContentRegistryCore.java - 内容注册核心实现（新增）
```java
package tqlslib.core;

import tqlslib.api.ContentRegistry;
import mindustry.mod.ClassMap;

public class ContentRegistryCore implements ContentRegistry {
    private static final String PREFIX = "tqls-";
    
    @Override
    public void registerClass(String name, Class<?> clazz) {
        ClassMap.classes.put(PREFIX + name, clazz);
    }
    
    @Override
    public Class<?> getClass(String name) {
        return ClassMap.classes.get(PREFIX + name);
    }
    
    @Override
    public boolean hasClass(String name) {
        return ClassMap.classes.containsKey(PREFIX + name);
    }
    
    @Override
    public String getPrefix() {
        return PREFIX;
    }
}
```

### 3.3 配置系统设计（新增）

#### ConfigLoader.java - 配置加载器
```java
package tqlslib.config;

import arc.files.Fi;
import arc.util.Log;
import mindustry.Vars;

public class ConfigLoader {
    public static void loadModConfigs(String modName) {
        Fi modRoot = Vars.modDirectory.child(modName);
        if (!modRoot.exists()) {
            Log.warn("Mod directory not found: " + modName);
            return;
        }
        
        Fi configDir = modRoot.child("configs");
        if (!configDir.exists()) {
            Log.info("No configs directory found for mod: " + modName);
            return;
        }
        
        configDir.walk(file -> {
            if (file.extEquals("json") || file.extEquals("hjson")) {
                loadConfig(file);
            }
        });
    }
    
    public static void loadConfig(Fi configFile) {
        Log.info("Loading config: " + configFile.name());
        // 解析配置
    }
}
```

#### ContentParser.java - 内容解析器抽象基类
```java
package tqlslib.config;

import org.json.JSONObject;

public abstract class ContentParser<T> {
    public abstract T parse(JSONObject json);
    public abstract String getContentType();
    
    protected void validate(JSONObject json, String... requiredFields) {
        for (String field : requiredFields) {
            if (!json.has(field)) {
                throw new IllegalArgumentException("Missing required field: " + field);
            }
        }
    }
}
```

### 3.4 事件系统设计（新增）

#### TQLEvent.java - 事件基类
```java
package tqlslib.event;

import arc.util.Time;
import mindustry.Vars;

public abstract class TQLEvent {
    public final long timestamp;
    public final String sourceMod;
    
    protected TQLEvent() {
        this.timestamp = Time.millis();
        this.sourceMod = Vars.mods.getMod(getClass()).name;
    }
}
```

#### SpaceStationCreateEvent.java - 空间站创建事件
```java
package tqlslib.event.events;

import tqlslib.event.TQLEvent;
import tqlslib.type.SpaceStation;

public class SpaceStationCreateEvent extends TQLEvent {
    public final SpaceStation station;
    
    public SpaceStationCreateEvent(SpaceStation station) {
        this.station = station;
    }
}
```

#### EventBusImpl.java - 事件总线实现
```java
package tqlslib.event;

import arc.struct.ObjectMap;
import arc.struct.Seq;
import tqlslib.api.EventBus;
import java.util.function.Consumer;

public class EventBusImpl implements EventBus {
    private ObjectMap<Class<?>, Seq<Consumer<?>>> handlers = new ObjectMap<>();
    
    @Override
    public <T extends TQLEvent> void subscribe(Class<T> eventType, Consumer<T> handler) {
        handlers.get(eventType, Seq::new).add(handler);
    }
    
    @Override
    public <T extends TQLEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler) {
        Seq<Consumer<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.remove(handler);
        }
    }
    
    @Override
    public <T extends TQLEvent> void post(T event) {
        Seq<Consumer<?>> eventHandlers = handlers.get(event.getClass());
        if (eventHandlers != null) {
            for (Consumer<?> handler : eventHandlers) {
                ((Consumer<T>) handler).accept(event);
            }
        }
    }
}
```

---

## 四、开发优先级排序

### 阶段 1：架构基础与重构（P0 - 第 1 周）
**目标**：建立基础架构，重构现有代码以符合单一职责原则

| 任务 | 说明 | 依赖 |
|------|------|------|
| 1.1 创建 api 包 | 创建 api 目录结构 | - |
| 1.2 定义 API 接口 | 创建 SpaceStationAPI、ContentRegistry、EventBus | 1.1 |
| 1.3 修正 TQUtls 拼写 | 重命名为 TQUtils | - |
| 1.4 拆分工具类 | 将 TQUtils 拆分为 TQUtils、TimeUtils | 1.3 |
| 1.5 重构 SpaceStationManager | 提取核心逻辑到 SpaceStationCore | 1.2 |
| 1.6 创建 ContentRegistryCore | 实现内容注册核心 | 1.2 |
| 1.7 更新 TQLSlib | 使用新的架构 | 1.5, 1.6 |
| 1.8 测试验证 | 确保所有功能正常 | 1.7 |

**验收标准**：
- ✅ 代码编译通过
- ✅ 所有现有功能正常
- ✅ 类的职责清晰，符合单一职责原则

---

### 阶段 2：事件系统（P1 - 第 2 周）
**目标**：实现事件系统，支持模块间松耦合通信

| 任务 | 说明 | 依赖 |
|------|------|------|
| 2.1 创建 event 包 | 创建 event 目录结构 | 阶段 1 |
| 2.2 实现 TQLEvent 基类 | 事件基类 | 2.1 |
| 2.3 实现 EventBusImpl | 事件总线实现 | 2.2 |
| 2.4 定义具体事件 | SpaceStationCreateEvent、RemoveEvent、RenameEvent | 2.2 |
| 2.5 集成事件触发 | 在 SpaceStationCore 中触发事件 | 2.4 |
| 2.6 测试事件系统 | 验证事件订阅和发布 | 2.5 |

**验收标准**：
- ✅ 事件系统正常工作
- ✅ 空间站操作能正确触发事件
- ✅ 其他模组可以订阅事件

---

### 阶段 3：配置系统（P1 - 第 3-4 周）
**目标**：实现配置系统，支持 JSON 配置解析

| 任务 | 说明 | 依赖 |
|------|------|------|
| 3.1 创建 config 包 | 创建 config 目录结构 | 阶段 2 |
| 3.2 实现 ConfigLoader | 配置加载器 | 3.1 |
| 3.3 实现 ContentParser | 内容解析器抽象基类 | 3.1 |
| 3.4 实现 BlockParser | 方块解析器 | 3.3 |
| 3.5 实现 StatusParser | 状态效果解析器 | 3.3 |
| 3.6 实现 PlanetParser | 星球解析器 | 3.3 |
| 3.7 集成到 TQLSlib | 在加载流程中调用配置加载 | 3.2 |
| 3.8 测试配置系统 | 验证 JSON 配置加载 | 3.7 |

**验收标准**：
- ✅ 可以通过 JSON 定义方块
- ✅ 可以通过 JSON 定义状态效果
- ✅ 可以通过 JSON 定义星球
- ✅ 配置加载错误处理完善

---

### 阶段 4：内容注册表优化（P2 - 第 5 周）
**目标**：优化内容注册机制，提供统一的注册表

| 任务 | 说明 | 依赖 |
|------|------|------|
| 4.1 创建 content/registry 包 | 创建注册表目录 | 阶段 3 |
| 4.2 实现 ClassRegistry | 类注册表 | 4.1 |
| 4.3 迁移现有注册 | 将 TQLSlib 中的注册迁移到 ClassRegistry | 4.2 |
| 4.4 测试注册表 | 验证注册功能正常 | 4.3 |

**验收标准**：
- ✅ 所有类注册统一管理
- ✅ 向后兼容

---

### 阶段 5：文档与示例（P2 - 第 6 周）
**目标**：编写文档，创建示例模组

| 任务 | 说明 | 依赖 |
|------|------|------|
| 5.1 编写 API 文档 | Javadoc 文档 | 阶段 4 |
| 5.2 编写使用指南 | 如何使用 TQLSlib | 5.1 |
| 5.3 创建示例模组 | 演示 JSON 配置、API 使用 | 5.2 |
| 5.4 最终测试 | 完整集成测试 | 5.3 |

**验收标准**：
- ✅ API 文档完整
- ✅ 使用指南清晰
- ✅ 示例模组可运行
- ✅ 所有功能正常

---

## 五、时间节点规划

### 里程碑 M1：架构基础与重构（第 1 周）
- **开始**：第 1 天
- **结束**：第 7 天
- **交付物**：
  - api 包和接口定义
  - 重构后的 SpaceStationManager 和 SpaceStationCore
  - 修正后的工具类
  - 功能正常的模组

### 里程碑 M2：事件系统（第 2 周）
- **开始**：第 8 天
- **结束**：第 14 天
- **交付物**：
  - event 包和事件系统
  - 空间站相关事件
  - 事件触发集成

### 里程碑 M3：配置系统（第 3-4 周）
- **开始**：第 15 天
- **结束**：第 28 天
- **交付物**：
  - config 包和配置系统
  - BlockParser、StatusParser、PlanetParser
  - JSON 配置支持

### 里程碑 M4：内容注册表优化（第 5 周）
- **开始**：第 29 天
- **结束**：第 35 天
- **交付物**：
  - 统一的 ClassRegistry
  - 迁移完成的注册逻辑

### 里程碑 M5：文档与示例（第 6 周）
- **开始**：第 36 天
- **结束**：第 42 天
- **交付物**：
  - 完整的 API 文档
  - 使用指南
  - 示例模组
  - 最终发布版本

---

## 六、质量保障措施

### 6.1 代码质量保障

#### 代码审查
- 每个阶段完成后进行代码审查
- 重点检查：
  - 单一职责原则是否遵守
  - 模块间依赖是否合理
  - 命名是否规范
  - 注释是否充分

#### 静态分析
- 使用 IDE 静态分析工具
- 检查潜在的 bug
- 检查代码复杂度
- 检查代码重复

#### 测试策略
- **单元测试**：核心业务逻辑（SpaceStationCore、EventBusImpl）
- **集成测试**：模块间集成（配置系统 + 内容注册）
- **回归测试**：确保重构不破坏现有功能

### 6.2 架构质量保障

#### 依赖规则
```
api ← core ← ui
      ↓
type ← config
      ↓
util ← worlds
```

- api 包只能被依赖，不能依赖其他业务包
- core 包依赖 api 和 type
- ui 包依赖 api 和 core
- config 包依赖 api 和 type
- util 包不依赖任何其他业务包
- worlds 包依赖 type 和 util

#### 循环依赖检测
- 定期检查模块间是否有循环依赖
- 禁止任何形式的循环依赖

### 6.3 向后兼容性保障

#### 版本管理
- 遵循语义化版本（Semantic Versioning）
- MAJOR.MINOR.PATCH
  - MAJOR：不兼容的 API 修改
  - MINOR：向下兼容的功能性新增
  - PATCH：向下兼容的问题修正

#### 弃用策略
- 删除功能前，先标记为 @Deprecated
- 至少保留一个版本的过渡期
- 提供迁移文档

### 6.4 扩展性设计原则

1. **插件化架构**：功能模块可插拔
2. **SPI 机制**：使用 Java Service Provider Interface
3. **钩子方法**：在关键位置提供钩子
4. **配置驱动**：通过配置而非硬编码

---

## 七、风险评估与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|------|--------|------|---------|
| 重构引入 bug | 中 | 高 | 充分测试、分阶段重构、保留回退方案 |
| 性能下降 | 低 | 中 | 性能测试、基准测试、优化热点 |
| 向后兼容性问题 | 中 | 高 | 兼容性测试、版本兼容层 |
| 开发延期 | 中 | 中 | 合理排期、预留缓冲、优先级管理 |
| JSON 解析复杂 | 中 | 中 | 分步实现、先支持简单配置 |

---

## 八、成功标准

### 代码质量
✅ 代码符合 SOLID 原则  
✅ 类的平均代码行数减少 30%  
✅ 模块间耦合度降低 50% 以上  
✅ 无循环依赖  

### 功能完整性
✅ 所有现有功能正常  
✅ API 层完整可用  
✅ 事件系统正常工作  
✅ 配置系统支持 JSON  
✅ 内容注册表统一管理  

### 文档质量
✅ API 文档完整（Javadoc）  
✅ 使用指南清晰  
✅ 示例模组可运行  

### 测试质量
✅ 核心逻辑单元测试覆盖率 ≥ 80%  
✅ 集成测试通过  
✅ 回归测试通过  

### 性能
✅ 性能不低于重构前  
✅ 内存占用不增加  

---

## 九、后续规划

### 短期（1-2 个月）
- 收集用户反馈
- 修复 bug
- 优化性能
- 增加更多内容解析器

### 中期（3-6 个月）
- 支持更多配置格式
- 增加模组集成钩子
- 提供更多工具类
- 完善文档和示例

### 长期（6 个月以上）
- 建立模组生态
- 提供模组模板
- 建立测试框架
- 持续优化架构
