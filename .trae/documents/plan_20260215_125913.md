
# TQLSlib 模组架构规划与实施计划

## 一、功能需求分析

### 1.1 核心功能定位
- **前置库定位**：为其他模组提供可复用的基础功能
- **模块化设计**：各功能模块独立，低耦合
- **可扩展性**：易于添加新功能和扩展现有功能

### 1.2 功能需求清单

| 功能模块 | 需求描述 | 优先级 |
|---------|---------|--------|
| **空间站系统** | 一星球多空间站、创建/删除/重命名、数据持久化 | P0 |
| **工具类库** | 绘图工具、通用工具、时间/功率格式化 | P1 |
| **内容注册** | ClassMap 类注册、支持其他模组引用 | P1 |
| **配置系统** | JSON 配置读取、支持其他模组通过 JSON 定义内容 | P2 |
| **事件系统** | 自定义事件、事件总线 | P2 |

---

## 二、模块划分方案

### 2.1 核心架构设计原则

#### 设计理念
1. **单一职责原则 (SRP)**：每个类只负责一个功能领域
2. **开闭原则 (OCP)**：对扩展开放，对修改关闭
3. **依赖倒置原则 (DIP)**：依赖抽象而非具体实现
4. **接口隔离原则 (ISP)**：提供最小接口
5. **里氏替换原则 (LSP)**：子类可替换父类

### 2.2 模块划分

```
tqlslib/
├── api/                    # 公共 API 层（供其他模组调用）
│   ├── SpaceStationAPI.java
│   ├── ContentRegistry.java
│   └── EventBus.java
├── core/                   # 核心业务逻辑
│   ├── SpaceStationCore.java
│   ├── SpaceStationManager.java
│   └── SpaceStationIO.java
├── type/                   # 数据类型定义
│   ├── SpaceStation.java
│   ├── SpaceStationInfo.java
│   └── SpaceStationGenerator.java
├── ui/                     # UI 层
│   ├── SpaceStationDialogs.java
│   └── dialogs/           # 可扩展的对话框基类
├── config/                 # 配置系统（新增）
│   ├── ConfigLoader.java
│   ├── ContentParser.java
│   └── parser/            # 各种内容解析器
│       ├── BlockParser.java
│       └── StatusParser.java
├── util/                   # 工具类
│   ├── TQDrawf.java
│   ├── TQUtils.java       # 修正拼写
│   └── TimeUtils.java     # 拆分工具类
├── content/                # 内容定义
│   ├── MxStats.java
│   └── registry/           # 内容注册表
│       └── ClassRegistry.java
├── event/                  # 事件系统（新增）
│   ├── TQLEvent.java
│   ├── EventBus.java
│   └── events/
│       └── SpaceStationEvent.java
├── integration/            # 集成模块（可选）
│   └── hooks/              # 模组集成钩子
└── TQLSlib.java            # 主入口类
```

---

## 三、类结构设计

### 3.1 API 层设计

```java
// SpaceStationAPI.java - 空间站公共 API
public interface SpaceStationAPI {
    SpaceStation createStation(Planet parent, String name);
    boolean removeStation(String stationId);
    boolean renameStation(String stationId, String newName);
    Seq&lt;SpaceStationInfo&gt; getStationsByPlanet(Planet planet);
    SpaceStation getStationById(String stationId);
}

// ContentRegistry.java - 内容注册 API
public interface ContentRegistry {
    void registerClass(String name, Class&lt;?&gt; clazz);
    Class&lt;?&gt; getClass(String name);
    boolean hasClass(String name);
}

// EventBus.java - 事件总线 API
public interface EventBus {
    &lt;T extends TQLEvent&gt; void subscribe(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler);
    &lt;T extends TQLEvent&gt; void unsubscribe(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler);
    &lt;T extends TQLEvent&gt; void post(T event);
}
```

### 3.2 核心层设计

```java
// SpaceStationCore.java - 空间站核心逻辑
public class SpaceStationCore implements SpaceStationAPI {
    // 实现所有 API 方法
    // 包含业务逻辑验证
}

// SpaceStationManager.java - 管理器（简化为门面）
public class SpaceStationManager {
    private static SpaceStationCore core = new SpaceStationCore();
    
    public static SpaceStation createStation(Planet parent, String name) {
        return core.createStation(parent, name);
    }
    // 其他静态代理方法...
}
```

### 3.3 配置系统设计（新增）

```java
// ConfigLoader.java - 配置加载器
public class ConfigLoader {
    public static void loadModConfigs(String modName);
    public static void loadConfig(Fi configFile);
}

// ContentParser.java - 内容解析器抽象
public abstract class ContentParser&lt;T&gt; {
    public abstract T parse(JSONObject json);
    public abstract String getContentType();
}

// BlockParser.java - 方块解析器
public class BlockParser extends ContentParser&lt;Block&gt; {
    @Override
    public Block parse(JSONObject json) {
        // 解析方块配置
    }
}
```

### 3.4 事件系统设计（新增）

```java
// TQLEvent.java - 事件基类
public abstract class TQLEvent {
    public final long timestamp;
    public final String sourceMod;
    
    protected TQLEvent() {
        this.timestamp = Time.millis();
        this.sourceMod = Vars.mods.getMod(TQLSlib.class).name;
    }
}

// SpaceStationEvent.java - 空间站事件
public class SpaceStationCreateEvent extends TQLEvent {
    public final SpaceStation station;
    
    public SpaceStationCreateEvent(SpaceStation station) {
        this.station = station;
    }
}

// EventBus.java - 事件总线实现
public class EventBus implements tqlslib.api.EventBus {
    private ObjectMap&lt;Class&lt;?&gt;, Seq&lt;Consumer&lt;?&gt;&gt;&gt; handlers = new ObjectMap&lt;&gt;();
    
    @Override
    public &lt;T extends TQLEvent&gt; void subscribe(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler) {
        handlers.get(eventType, Seq::new).add(handler);
    }
    
    @Override
    public &lt;T extends TQLEvent&gt; void post(T event) {
        Seq&lt;Consumer&lt;?&gt;&gt; eventHandlers = handlers.get(event.getClass());
        if (eventHandlers != null) {
            for (Consumer&lt;?&gt; handler : eventHandlers) {
                ((Consumer&lt;T&gt;) handler).accept(event);
            }
        }
    }
}
```

---

## 四、开发优先级排序

### 阶段一：架构重构与优化（P0）
1. 重构现有代码，遵循单一职责原则
2. 拆分 TQUtls → TQUtils（修正拼写）
3. 重构 TQLSlib.java，简化职责
4. 建立基础包结构

### 阶段二：API 层建设（P0）
1. 创建 api 包
2. 定义 SpaceStationAPI 接口
3. 定义 ContentRegistry 接口
4. 实现 API 层与现有代码的桥接

### 阶段三：配置系统（P2）
1. 创建 config 包
2. 实现 ConfigLoader 配置加载器
3. 实现 ContentParser 抽象基类
4. 实现 BlockParser、StatusParser 等具体解析器
5. 集成到 TQLSlib 加载流程

### 阶段四：事件系统（P2）
1. 创建 event 包
2. 实现 TQLEvent 基类
3. 实现 EventBus 事件总线
4. 定义 SpaceStationEvent 等具体事件
5. 在关键点触发事件

### 阶段五：文档与示例（P3）
1. 编写使用文档
2. 创建示例模组
3. 编写测试用例

---

## 五、时间节点规划

### 里程碑 M1：架构优化（1周）
- [ ] 代码重构完成
- [ ] 包结构调整完成
- [ ] 编译通过，所有现有功能正常

### 里程碑 M2：API 层（1周）
- [ ] API 接口定义完成
- [ ] API 实现完成
- [ ] 向后兼容性验证

### 里程碑 M3：配置系统（2周）
- [ ] 配置加载器完成
- [ ] 内容解析器完成
- [ ] JSON 配置支持验证

### 里程碑 M4：事件系统（1周）
- [ ] 事件基类完成
- [ ] 事件总线完成
- [ ] 事件触发点集成完成

### 里程碑 M5：文档与测试（1周）
- [ ] 使用文档编写完成
- [ ] 示例模组完成
- [ ] 测试用例完成

**总计：6周**

---

## 六、质量保障措施

### 6.1 代码质量保障

| 措施 | 说明 |
|------|------|
| **代码审查** | 每个阶段完成后进行代码审查 |
| **静态分析** | 使用 IDE 静态分析工具检查 |
| **单元测试** | 核心业务逻辑编写单元测试 |
| **集成测试** | 模块间集成测试 |

### 6.2 架构质量保障

- **依赖图监控**：使用工具监控模块依赖关系
- **循环依赖检测**：禁止模块间循环依赖
- **包依赖规则**：
  - api 包只能被其他包依赖，不能依赖其他包
  - core 包依赖 api 和 type 包
  - ui 包依赖 api 和 core 包
  - util 包不依赖任何其他业务包

### 6.3 向后兼容性保障

- **版本号管理**：遵循语义化版本
- **@Deprecated 注解**：删除功能前先标记为过时
- **迁移文档**：每个版本发布时提供迁移指南

### 6.4 扩展性设计原则

1. **插件化架构**：功能模块可插拔
2. **SPI 机制**：使用 Java Service Provider Interface
3. **钩子方法**：在关键位置提供钩子
4. **配置驱动**：通过配置而非硬编码

---

## 七、风险评估与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|------|--------|------|---------|
| 重构引入 bug | 中 | 高 | 充分测试、分阶段重构 |
| 性能下降 | 低 | 中 | 性能测试、基准测试 |
| 向后兼容性问题 | 中 | 高 | 兼容性测试、版本兼容层 |
| 开发延期 | 中 | 中 | 合理排期、预留缓冲 |

---

## 八、成功标准

✅ 代码符合 SOLID 原则  
✅ 模块间耦合度降低 50% 以上  
✅ 类的平均代码行数减少 30%  
✅ 完整的 API 文档  
✅ 通过所有测试用例  
✅ 性能不低于重构前  
